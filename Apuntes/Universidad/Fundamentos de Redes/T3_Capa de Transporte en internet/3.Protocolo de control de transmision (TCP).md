
```ad-abstract
EL protocolo TCP (Transmision Control Protocol) forma junto con *IP*, el corazón de la arquitectura de internet, dándole el nombre *TCP/IP*.
```

## Características:
?
1. Servicio orientado a conexión, permitiendo envío secuencial de los datos. Lo que es lo mismo, los datos se reciben en el mismo orden que se transmiten (Es lo que se conoce como envío orientado a flujo). 
2. Exige un estado común entre emisor y receptor (***Hand shaking***):
	1. Establecimiento
	2. Intercambio de datos
	3. Cierre
3. Servicio **punto a punto**, no se puede utilizar para conexiones *multicast* (de uno a muchos).
4. Es un servicio **flux-duplex**. Se puede hablar y responder a la vez
5. Es un servicio de **extremo a extremo fiable**, con mecanismos para la detección y recuperación de errores (==ARQ==), con confirmaciones (==ACK==) y **con control de flujo y congestión**.
6. TCP se adapta a las condiciones de la red dinámicamente.

### Funcionalidades:
?
1. [[#Multiplexación/Demultiplexación|Multiplexación y demultiplexación de aplicaciones]]
2. [[#Control de la conexión]] -> Establecimiento y cierre
3. Control de errores y flujo
4. Control de congestión


```ad-seealso
TCP es ideal para transmisiones de datos de larga distancia para aplicaciones que exigen un servicio fiable.
```

## Datagrama de TCP

```ad-important
title:TDPU de TCP
Son los conocidos como segmentos TCP
![[Pasted image 20231121170533.png]]
```

### Campos:
?
1. *Puertos origen* y *destino*
2. *[[#Secuencia]]* -> N° de secuencia del primer byte del segmento de datos
3. *Acuse* -> N° del byte que se espera recibir (acumulativo).
4. *HLEN* -> Tamaño de la cabecera TCP
5. *Reservado* -> 3 bits sin uso específico (000)
6. *Datos* -> el mensaje generado por la aplicación
7. *Opciones* -> Longitud variable -> Metadatos
8. *Ventana* -> Permite el control de flujo
9. *Puntero* -> Permite el envio de los datos a los que apunta fuera de banda
10. *Control* -> Bits de control.
	![[#Posibles segmentos a recibir]]
#### Secuencia:
?
```ad-important
title:Secuencia
Campo de 32 bits que cuenta bytes en módulo 232 (el contador da la vuelta si supera el máximo). No se empieza en 0 sino en un valor aleatorio llamado **ISN (Initial Secuence Number)** elegido teóricamente "*al azar*" para evitar confusiones con mensajes anteriores. 

```ad-seealso
Al ser numéros pseudoaleatorios se podría realizar un ataque por suplantación.

```

```ad-seealso
title: Incremento de Secuencia
TCP incrementa el número de cada segmento según los bytes que tenía el segmento anterior, con una sola excepción, los flags **SYN** y **FIN** incrementan en **1** el número de secuencia
```



## Multiplexación/Demultiplexación
?
```ad-important
Permite que varias aplicaciones ejecutadas en un mismo *host* puedan comunicarse entre si si son TCP. El campo de los puertos identifican los procesos en los terminales de conexión que requieren los datos.
```

#### Puertos preasignados

![[Pasted image 20231121171704.png]]

```ad-important

Como en UDP, Los puertos mayores a 1024 están disponibles para el desarrollador.

```

```ad-seealso
Algunos servicios permiten usar tanto TCP como UDP. Se conocen como servicion multiprotocolo.
```

## Control de la conexión

```ad-abstract
La conexión previa a la transmisión con TCP, es como una especie de circuito virtual, que implica acoplar las entidades origen y destino mediante la definición de un estado común a ambas.
```

El intercambio de la información tiene 3 fases:
?
- [[#1. Establecimiento conexión]]
- [[#2. Intercambio de datos]]
- [[#3. Cierre de la conexión]]

### Fases de la conexión

#### 1. Establecimiento conexión
?
1. **Solicitud de conexión**::Se envía un segmento con solo cabecera y el bit. Un mensaje de tipo *SYN*. Solicitando el establecimiento de la conexión.
2. **Aceptación de conexión y solicitud en el otro sentido**::En el caso de aceptar la conexión. El otro extremo responde con un segmento con el bit *ACK* activado. Un mensaje *SYN ACK*.
3. **Conexión establecida**::La conexión queda establecida una vez que el extremo origen responde otra vez con un mensaje *ACK*, en respuesta a la solicitud de recursos del SO por parte del otro extremo.
![[Pasted image 20231121173829.png]]
####  2. Intercambio de datos
?
Intercambio de conexión full-duplex, en los dos sentidos.

#### 3. Cierre de la conexión
?
1. **Solicitud de cierre**::Cuando cualquiera de las dos entidades TCP no tenga más datos que transmitir, se envía un segmento TCP con el bit *Fin*=1
2. **Aceptación de cierre y solicitud en el otro sentido**:: El otro extremo debe confirmar la solicitud enviando un segmento con el bit *ACK* activado
3. **Conexión finalizada**::La conexión TCP finaliza cuando el extremo que originó el primer *FIN* genera un segmento con *ACK* activado como respuesta al segmento recibido
4. ![[Pasted image 20231121174137.png]]

### Estados del protocolo
```ad-seealso
1. Los segmentos *ACK* sin datos no aumentan el número de secuencia.
2. El campo *ACK* también está numerado, indica una cuenta en bytes que comfirma todos los *ACKs* inferiores en numeración (control de paquetes perdidos)
```

#### Posibles segmentos a recibir
?
1. *U*-> Urgent
2. *A*-> ACK
	1. Los segmentos *ACK* sin datos no aumentan el número de secuencia.
	2. El campo *ACK* también está numerado, indica una cuenta en bytes que comfirma todos los *ACKs* inferiores en numeración (control de paquetes perdidos)
3. *P*-> Push
4. *R*-> Reset
5. *S*-> Sincronice (Establecer)
6. *F*-> Fin (Cerrar conexión)

#### Autómata de estados finitos del protocolo TCP

![[Pasted image 20231121193802.png]]


#### Posibles problemas

**Conexión simultánea**::Mandan un SYN a la vez y luego mandan SYN+ACK a la vez, dando información redundante que gasta recursos.

***SYN* retrasados y duplicados**::Pueden perderse *SYN*, o tardar más que los siguientes paquetes, causando *ACKs* fuera de orden y paquetes perdidos.

#### Cotrol de conexión
?
1. Un host manda una señar de cierre -> **Cierre Activo**
2. El otro host recive una señal de cierre, lo confirma y pone el bit de *fin* a 1 -> **Cierre pasivo**


## Control de errores y flujo

```ad-abstract
Cuando TCP manda un segmento arranca un *timer*, cuando el timer alcanza un valor, si no ha llegado un *ACK*, entonces manda una interrupción del sistema (**TIMEOUT**) y el segmento se vuelve a repetir. Tantas veces como haga falta para que el segmento llegue a su destino. 

Para aprovechar los recursos de la computadora, se mandan varios segmentos de 1 en 1 y **creando un contador de tiempo para cada uno de los segmentos** aprovechando los recursos sin bloquear la espera de un solo paquete.

Cualquiera de los paquetes se puede perder y cualquiera puede tener errores, así que en la memoria del emisor **se hace una copia de cada segmento que se envía** con el objetivo de reenviarlo en caso de necesitarlo.
```